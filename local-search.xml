<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java多线程</title>
    <link href="/2022/10/22/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8A%80%E6%9C%AF%20_%20%20%E7%BA%BF%E7%A8%8B%E7%94%9F%E6%88%90%20_%20%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    <url>/2022/10/22/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8A%80%E6%9C%AF%20_%20%20%E7%BA%BF%E7%A8%8B%E7%94%9F%E6%88%90%20_%20%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="java多线程"><a href="#java多线程" class="headerlink" title="java多线程"></a>java多线程</h1><hr><p>@<a href="%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95">TOC</a></p><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>java多线程技术相关用法呈现</p><hr><h1 id="一、生成多线程"><a href="#一、生成多线程" class="headerlink" title="一、生成多线程"></a>一、生成多线程</h1><h2 id="1-继承Thread类"><a href="#1-继承Thread类" class="headerlink" title="1.继承Thread类"></a>1.继承Thread类</h2><blockquote><p>创建一个Thread的<strong>子类</strong>的一个实例即创建了一个线程<br>换句话说，它的一个实例 就是一个线程</p></blockquote><p>利用此方法，创建一个Thread的子类的一个实例就是创建了一个线程，<strong>子类中描述了一个线程要做的工作</strong>，因此若多线程要完成不同的工作就要创建多个不同的子类。</p><p>一个子类多次实例化就创建了多个相同的线程，需要注意的是：若子类中含有static类变量，那么这一个子类的多个线程便会操作同一个变量。</p><h2 id="2-实现Runnable接口"><a href="#2-实现Runnable接口" class="headerlink" title="2.实现Runnable接口"></a>2.实现Runnable接口</h2><blockquote><p>将Runnable的一个实现类的一个<strong>实例</strong>放入Thread( ) 构造器中，通过Thread构造器创建线程</p></blockquote><p>通过这种方法，放入同一个实现类实例创建出的多个线程总是会操作这一个实例内的同一些成员变量，当然也完成相同的操作</p><p>因此要完成不同的操作就需要不同的实现类</p><h2 id="3-实现Callable接口"><a href="#3-实现Callable接口" class="headerlink" title="3.实现Callable接口"></a>3.实现Callable接口</h2><blockquote><p>将Callable的实现类的一个<strong>实例</strong>放入FutureTask构造器中创建FutureTas<strong>k实例</strong>，再将Futuretask<strong>实例</strong>放入Thread构造器中创建出一个线程</p></blockquote><h2 id="4-线程池"><a href="#4-线程池" class="headerlink" title="4.线程池"></a>4.线程池</h2><blockquote><p>调用Executors的newFixedThreadPool( )或.newCachedThreadPool(<br>)方法创建出ExecutorService的一个实例，调用该实例的execute( )方法或submit(<br>)方法，在方法中提交含有线程操作的实现Runnable接口或Callable接口实现类对象</p></blockquote><p>说明：<br> execute( )适用于Runnable<br> submit(   ) 适合适用于Callable</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//1.提供指定线程数量的线程池</span><br>ExecutorService service = Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br>ThreadPoolExecutor service1 = (ThreadPoolExecutor) service;<br><span class="hljs-comment">//设置线程池的属性</span><br><span class="hljs-comment">//        System.out.println(service.getClass());</span><br><span class="hljs-comment">//        service1.setCorePoolSize(15);</span><br><span class="hljs-comment">//        service1.setKeepAliveTime();</span><br><br><span class="hljs-comment">//2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象。</span><br>service.execute(new NumberThread()); <span class="hljs-comment">//适合用于Runnable</span><br><span class="hljs-comment">//        service.submit(); 适合适用于Callable</span><br><span class="hljs-comment">//关闭线程池</span><br>service.shutdown();<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/734b75fd8aed4cb5b351991ad4ee9adc.png"></p><h1 id="二、锁"><a href="#二、锁" class="headerlink" title="二、锁"></a>二、锁</h1><blockquote><p>一个Thread子类的实例只能构造一个线程</p></blockquote><blockquote><p> 一个Runnable实现类的实例可以构造多个线程</p></blockquote><p><code>synchronized(同步监视器)&#123;需要被同步的代码&#125;</code></p><h2 id="1-Syncronized同步锁"><a href="#1-Syncronized同步锁" class="headerlink" title="1.Syncronized同步锁"></a>1.Syncronized同步锁</h2><p>关于锁的选择：</p><ul><li><p>自行创建，共用对象，如下面demo中的Object对象。</p></li><li><p>使用this表示当前类的对象</p></li><li><p>继承Thread的方法中的锁不能使用this代替，因为继承thread实现多线程时，会创建多个子类对象来代表多个线程，这个时候this指的时当前这个类的多个对象，不唯一，无法当作锁。</p></li><li><p>实现Runnable接口的方式中，this可以当作锁，因为这种方式只需要创建一个实现类的对象，将实现类的对象传递给多个Thread类对象来当作多个线程，this就是这个一个实现类的对象，是唯一的，被所有线程所共用的对象。</p></li><li><p>使用类当作锁，以下面demo为例，其中的锁可以写为WindowThread.class, 从这里可以得出结论，类也是一个对象</p></li></ul><h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c">private <span class="hljs-type">int</span> tiketsNum = <span class="hljs-number">100</span>;<br>   <br>  <span class="hljs-comment">//由于，Runnable实现多线程，所有线程共用一个实现类的对象，所以三个线程都共用实现类中的这个Object类的对象。</span><br>   Object obj = new Object();<br>   <span class="hljs-comment">//如果时继承Thread类实现多线程，那么需要使用到static Object obj = new Object();</span><br>   <br>public <span class="hljs-type">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>       <br>  <span class="hljs-comment">//Object obj = new Object();</span><br>    <span class="hljs-comment">//如果Object对象在run()方法中创建，那么每个线程运行都会生成自己的Object类的对象，并不是三个线程的共享对象，所以并没有给加上锁。</span><br>       <br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>           synchronized (obj) &#123;<br>               <span class="hljs-keyword">if</span> (tiketsNum &gt; <span class="hljs-number">0</span>) &#123;<br>                   try &#123;<br>                       <span class="hljs-comment">//手动让线程进入阻塞,增大安全性发生的概率</span><br>                       Thread.sleep(<span class="hljs-number">100</span>);<br>                   &#125; catch (InterruptedException e) &#123;<br>                       e.printStackTrace();<br>                   &#125;<br>                   System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;:\t票号:&quot;</span> + tiketsNum + <span class="hljs-string">&quot;\t剩余票数:&quot;</span> + --tiketsNum);<br>               &#125; <span class="hljs-keyword">else</span> &#123;<br>                   <span class="hljs-keyword">break</span>;<br>               &#125;<br>           &#125;<br>       &#125;<br></code></pre></td></tr></table></figure><h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><p>同步方法仍然涉及到同步监视器，只是不需要我们显示的声明。<br>非静态的同步方法，同步监视器是：this。<br>静态的同步方法，同步监视器是：当前类本身。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Window02Thread</span> implements Runnable &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> tiketsNum = <span class="hljs-number">100</span>;<br><br>    @<span class="hljs-function">Override</span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (tiketsNum &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">show</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//同步监视器：this</span><br>        <span class="hljs-keyword">if</span> (tiketsNum &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//手动让线程进入阻塞,增大安全性发生的概率</span><br>                Thread.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">100</span>);<br>            &#125; <span class="hljs-built_in">catch</span> (InterruptedException e) &#123;<br>                e.<span class="hljs-built_in">printStackTrace</span>();<br>            &#125;<br>            System.out.<span class="hljs-built_in">println</span>(Thread.<span class="hljs-built_in">currentThread</span>().<span class="hljs-built_in">getName</span>() + <span class="hljs-string">&quot;:\t票号:&quot;</span> + tiketsNum + <span class="hljs-string">&quot;\t剩余票数:&quot;</span> + --tiketsNum);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Window03Thread</span> <span class="hljs-title">extends</span> <span class="hljs-title">Thread</span> &#123;</span><br>    public <span class="hljs-type">static</span> <span class="hljs-type">int</span> tiketsNum = <span class="hljs-number">100</span>;<br><br>   @Override<br>    public <span class="hljs-type">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (tiketsNum &gt; <span class="hljs-number">0</span>) &#123;<br>            show();<br>        &#125;<br>    &#125;<br><br>   public <span class="hljs-type">static</span> synchronized <span class="hljs-type">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">//同步监视器：Winddoe03Thread.class  不加static话同步监视器为t1 t2 t3所以错误</span><br>        <span class="hljs-keyword">if</span> (tiketsNum &gt; <span class="hljs-number">0</span>) &#123;<br>            try &#123;<br>                <span class="hljs-comment">//手动让线程进入阻塞,增大安全性发生的概率</span><br>                Thread.sleep(<span class="hljs-number">100</span>);<br>            &#125; catch (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;:\t票号:&quot;</span> + tiketsNum + <span class="hljs-string">&quot;\t剩余票数:&quot;</span> + --tiketsNum);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-Lock锁"><a href="#2-Lock锁" class="headerlink" title="2.Lock锁"></a>2.Lock锁</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SafeLockThread</span> <span class="hljs-title">implements</span> <span class="hljs-title">Runnable</span>&#123;</span><br>    private <span class="hljs-type">int</span> tickets = <span class="hljs-number">100</span>;<br>    private ReentrantLock lock = new ReentrantLock();<br><br>   @Override<br>    public <span class="hljs-type">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (tickets&gt;<span class="hljs-number">0</span>) &#123;<br>            try &#123;<br>                <span class="hljs-comment">//在这里锁住，有点类似同步监视器</span><br>                lock.lock();<br>                <span class="hljs-keyword">if</span> (tickets &gt; <span class="hljs-number">0</span>) &#123;<br>                    Thread.sleep(<span class="hljs-number">100</span>);<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;:\t票号:&quot;</span> + tickets + <span class="hljs-string">&quot;\t剩余票数:&quot;</span> + --tickets);<br>                &#125;<br>            &#125; catch (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125; finally &#123;<br>                <span class="hljs-comment">//操作完成共享数据后在这里解锁</span><br>                lock.unlock();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="两种锁之间的异同"><a href="#两种锁之间的异同" class="headerlink" title="两种锁之间的异同"></a>两种锁之间的异同</h2><blockquote><ol><li>Lcok是显式锁（需要手动开启和关闭锁），synchronized是隐式锁，除了作用域自动释放。</li><li>Lock只有代码块锁，synchronized有代码块锁和方法锁。</li><li>使用Lcok锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的拓展性（提供更多的子类</li></ol></blockquote><h2 id="关于死锁："><a href="#关于死锁：" class="headerlink" title="关于死锁："></a>关于死锁：</h2><p>无</p><hr><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="三-线程之间的通信"><a href="#三-线程之间的通信" class="headerlink" title="三.线程之间的通信"></a>三.线程之间的通信</h1><h3 id="相关方法："><a href="#相关方法：" class="headerlink" title="相关方法："></a>相关方法：</h3><blockquote><p>​ wait()：一旦执行此方法，当前线程就会进入阻塞，一旦执行wait()会释放同步监视器。</p></blockquote><blockquote><p>​ notify()：一旦执行此方法，将会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先度最高的。</p></blockquote><blockquote><p>​ notifyAll() ：一旦执行此方法，就会唤醒所有被wait的线程</p></blockquote><p>​ <strong>说明：</strong></p><ul><li><p>​  这三个方法必须在同步代码块或同步方法中使用。</p></li><li><p>三个方法的调用者必须是同步代码块或同步方法中的同步监视器。</p></li><li><p>这三个方法并不定义在Thread类，而是定义在Object类当中。（因为所有的对象都可以作为同步监视器，而这三个方法需要由同步监视器调用，所以任何一个类都要满足，那么只能写在Object类中）</p></li><li><p>在while循环里而不是if语句下使用wait，这样，会在线程暂停恢复后都检查wait的条件，并在条件实际上并未改变的情况下处理唤醒通知</p></li></ul><h2 id="sleep-和wait-的异同"><a href="#sleep-和wait-的异同" class="headerlink" title="sleep()和wait()的异同"></a>sleep()和wait()的异同</h2><blockquote><p>相同点：两个方法一旦执行，都可以让线程进入阻塞状态。</p><p>不同点：<br>(1) 两个方法声明的位置不同：Thread类中声明sleep(),Object类中声明wait()</p><p>(​2) 调用要求不同：sleep()可以在任何需要的场景下调用。wait()必须在同步代码块中调用。</p><p>(​3) 关于是否释放同步监视器：如果两个方法都使用在同步代码块和同步方法中，sleep不会释放锁，wait会释放锁。</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>tnnd我c盘怎么又爆了</title>
    <link href="/2022/09/25/c/"/>
    <url>/2022/09/25/c/</url>
    
    <content type="html"><![CDATA[<p>西八~~~~</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数字逻辑基础</title>
    <link href="/2022/09/25/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%EF%BC%881%EF%BC%89/"/>
    <url>/2022/09/25/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%EF%BC%881%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="数字逻辑基础"><a href="#数字逻辑基础" class="headerlink" title="数字逻辑基础"></a>数字逻辑基础</h1><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>作为大多数计算机体系结构课程的第一课</p><p>可以说这是我们认识计算机原理的第一步</p><hr><h1 id="一、数值进位制之间的转换"><a href="#一、数值进位制之间的转换" class="headerlink" title="一、数值进位制之间的转换"></a>一、数值进位制之间的转换</h1><blockquote><p>基本概念：基数的个数&#x3D;权</p></blockquote><h2 id="1-与十进制相关的转换"><a href="#1-与十进制相关的转换" class="headerlink" title="1.与十进制相关的转换"></a>1.与十进制相关的转换</h2><h3 id="（1）十进制转化为二、八、十六进制："><a href="#（1）十进制转化为二、八、十六进制：" class="headerlink" title="（1）十进制转化为二、八、十六进制："></a>（1）十进制转化为二、八、十六进制：</h3><p>整数部分除2、8、16取余（最后取得的余数是最高位），小数部分乘2、8、16取整（最先取得的数是最高位）</p><h3 id="（2）其他进制转化为十进制："><a href="#（2）其他进制转化为十进制：" class="headerlink" title="（2）其他进制转化为十进制："></a>（2）其他进制转化为十进制：</h3><p>按权位展开即可（8进制与16进制转化为十进制同理）</p><h2 id="2-二进制与八、十六进制的转换"><a href="#2-二进制与八、十六进制的转换" class="headerlink" title="2.二进制与八、十六进制的转换"></a>2.二进制与八、十六进制的转换</h2><h3 id="（1）二进制转化为八、十六进制"><a href="#（1）二进制转化为八、十六进制" class="headerlink" title="（1）二进制转化为八、十六进制"></a>（1）二进制转化为八、十六进制</h3><p>以小数点为起点，3位、4位为一组（不足为一组的补0），以组为单位转换</p><h3 id="（2）八、十六进制转化为二进制"><a href="#（2）八、十六进制转化为二进制" class="headerlink" title="（2）八、十六进制转化为二进制"></a>（2）八、十六进制转化为二进制</h3><p>将每一位数字转化为3位、4位的对应进制数</p><blockquote><p>介绍完数据的表示，我们有必要了解符号数的表示以及它们的运算是如何进行的</p></blockquote><h1 id="二、机器数"><a href="#二、机器数" class="headerlink" title="二、机器数"></a>二、机器数</h1><blockquote><p>数通常由符号位与数值位组成，符号位通常以0表示正数，1表示负数</p></blockquote><h2 id="1-三种机器数：原码、反码、补码"><a href="#1-三种机器数：原码、反码、补码" class="headerlink" title="1.三种机器数：原码、反码、补码"></a>1.三种机器数：原码、反码、补码</h2><h3 id="（1）原码"><a href="#（1）原码" class="headerlink" title="（1）原码"></a>（1）原码</h3><p>真值的二进制序列加上符号位就是原码<br>原码0有两种表现形式：0.000与1.000</p><h3 id="（2）反码"><a href="#（2）反码" class="headerlink" title="（2）反码"></a>（2）反码</h3><p>正数的反码等于原码<br>负数的反码是除符号位外，其余位按位求反（01互换）<br>反码0有两种表现形式：0.000与1.111</p><h3 id="（3）补码"><a href="#（3）补码" class="headerlink" title="（3）补码"></a>（3）补码</h3><p>正数的补码等于原码<br>负数的补码是除符号位外，其余位按位求反，再整体+1<br>补码0的表示是唯一的：0.000</p><h2 id="2-机器数的运算"><a href="#2-机器数的运算" class="headerlink" title="2.机器数的运算"></a>2.机器数的运算</h2><p>对于原码，先对真值二进制数进行运算，最后添加符号位</p><h3 id="补码运算："><a href="#补码运算：" class="headerlink" title="补码运算："></a>补码运算：</h3><blockquote><p><em><strong>对补码再求补码或反码再求反码即可得到原码</strong></em></p></blockquote><p>补码直接参与运算，符号位产生进位时舍弃溢出部分<br>结果的符号位为0时，说明是正数的补码，其与原码相同。符号位为1时，说明是负数的补码，应再对运算结果再求补码，才得到原码。<br><img src="https://img-blog.csdnimg.cn/4b953f4029cd453ba10488e90e5c5491.png"><br><img src="https://img-blog.csdnimg.cn/e21dd1714c79473faf228b9fb9019d03.png"></p><h3 id="反码运算"><a href="#反码运算" class="headerlink" title="反码运算"></a>反码运算</h3><p><img src="https://img-blog.csdnimg.cn/62022fea85594e07ab85082772a400a7.png"><br>        运算时，符号位参加运算，如果符号位产生了进位，则该进位应该加到和数的最低位，称之为“循环进位”。<br>        运算结果符号位为0时，说明是正数的反码，其与原码相同。若符号位为1，说明是负数的反码，应对结果再求反码才能得到原码。</p><h1 id="三、浮点数的表示、IEEE754标准"><a href="#三、浮点数的表示、IEEE754标准" class="headerlink" title="三、浮点数的表示、IEEE754标准"></a>三、浮点数的表示、IEEE754标准</h1><p>浮点数的表示有两部分组成：阶码E+尾数M<br>真值    N &#x3D; ± R^E ×M<br>概念冗杂（哈哈哈）<br>我们直接来例子：<img src="https://img-blog.csdnimg.cn/d764307f7f7648e09752421494505dc4.png"><br><img src="https://img-blog.csdnimg.cn/b8f27030c15c4107a6f930d20b028efa.png"><br><img src="https://img-blog.csdnimg.cn/0312d37670ef4158871885af4ada8322.png"><br><img src="https://img-blog.csdnimg.cn/e08af18ff57c41bb9c6f6495bbc96ea4.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/09/18/hello-world/"/>
    <url>/2022/09/18/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
