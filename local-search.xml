<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/10/27/%E4%BC%9A%E8%AE%AE%E5%AE%A4%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/"/>
    <url>/2022/10/27/%E4%BC%9A%E8%AE%AE%E5%AE%A4%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><h2 id="编写目的"><a href="#编写目的" class="headerlink" title="编写目的"></a>编写目的</h2><p>​本文档的目的是详细地介绍“基于React和SpringBoot的多平台会议室管理系统”所包含的需求，以便客户能够确认产品的确切需求以及开发人员能够根据需求设计编码，以下叙述将结合文字描述、数据流图、ER图等来描述该系统的功能、性能、用户界面（包括管理员界面、普通用户界面）、运行环境、外部接口以及针对用户操作给出的各种响应。本文档的预期读者有客户、开发人员以及跟该项目相关的其他竞争人员。</p><h1 id="任务概述"><a href="#任务概述" class="headerlink" title="任务概述"></a>任务概述</h1><h2 id="项目概述"><a href="#项目概述" class="headerlink" title="项目概述"></a>项目概述</h2><h3 id="项目来源及背景"><a href="#项目来源及背景" class="headerlink" title="项目来源及背景"></a>项目来源及背景</h3><p>​会议室的预定和管理问题，在企业、园区、学校等人员组织多，会议多的地方非常的普遍。纯电脑端的会议预定系统，看的人少，经常发生会议冲突的问题；而在门口填写预定信息，则不知道哪个会议室有空。在企业里，就经常会碰到类似问题：临时开会，找了多个会议室都有人在开会；预定了会议室，有人会议延迟太久结束，影响后面的人开会;有人未预定会议室却在使用。</p><p>​所以我们推出“基于React和SpringBoot的多平台会议室管理系统”，这是一个针对企业、园区、学校人员的智能会议管理系统，使用者可以在这里获得良好的会议体验。</p><h3 id="项目目标"><a href="#项目目标" class="headerlink" title="项目目标"></a>项目目标</h3><p>​该项目的市场目标为企业、园区、学校人员等群体、会议预定和管理软件市场，应用目标为实现会议预定和管理智能化，不掺杂其他功能。</p><h3 id="系统功能概述"><a href="#系统功能概述" class="headerlink" title="系统功能概述"></a>系统功能概述</h3><ul><li>管理端<ol><li>查询用户和会议室</li><li>添加用户和会议室</li><li>修改用户和会议室</li><li>删除用户和会议室</li></ol></li><li>预定端<ol><li>查看公告和邀请信息</li><li>查看已预约的会议</li><li>查看需参与的会议</li><li>预约会议</li><li>修改个人信息</li></ol></li></ul><h2 id="用户特点"><a href="#用户特点" class="headerlink" title="用户特点"></a>用户特点</h2><p>​本系统的用户主要是在企业、园区、学校等场所工作或学习的群体，这类人群的主要特点是需要经常性地预定或参与会议，在本系统上可以便捷地管理、预定、参与会议室，以满足自己的会议需求。</p><h1 id="功能需求"><a href="#功能需求" class="headerlink" title="功能需求"></a>功能需求</h1><h2 id="功能划分"><a href="#功能划分" class="headerlink" title="功能划分"></a>功能划分</h2><h3 id="系统功能组成"><a href="#系统功能组成" class="headerlink" title="系统功能组成"></a>系统功能组成</h3><ol><li><p>系统的顶层数据流图</p><p><img src="https://pic1.imgdb.cn/item/635a21c516f2c2beb1a20c4d.jpg" alt="会议室管理系统顶层数据流图"></p><p>描述：系统的使用者可以扮演两种角色——管理员和普通用户。使用者扮演管理员的角色时，可以向系统发送事务，同时管理员可以浏览系统返回的事务，即管理员与系统有双向的数据流动。当使用者扮演普通用户的角色时，可以向系统发送事务，同时普通用户可以浏览系统返回的事务，即普通用户与系统也有双向的数据流动。</p></li><li><p>系统的0层数据流图</p><p><img src="https://tva2.sinaimg.cn/large/006hWKQzly8h7k6z9b3x2j315v0u0gu3.jpg"></p><p>描述：用户（包括两种角色——管理员、普通用户）通过提交身份信息向用户登录事务发送请求。用户登录事务从用户信息库中读取相应的用户信息进行匹配判断登录结果。用户登录成功后，管理员可以查询、添加、修改、删除会议室和用户，通过添加用户邀请其他普通用户，并根据企业内部情况对会议室及其他普通用户进行使用权限管理；普通用户可发起会议或加入会议，若想发起会议需要进行预约，预约时查询并选择时间段、填写会议主题并添加与会人（如有变动可修改预约信息），系统将自动给与会人发送通知邮件，与会人若要加入会议，可通过该系统刷脸签到会议。</p></li></ol><h2 id="功能描述"><a href="#功能描述" class="headerlink" title="功能描述"></a>功能描述</h2><ol><li><p>用户登录</p><p>功能描述：用户登录可以分为注册和登陆。注册时用户提供新用户注册信息发往注册事务，注册事务根据新用户注册信息得到新用户信息存入用户信息库，同时流动出用户信息。登录时用户提供用户名和密码发往登录事务，登录事务将得到的用户名和密码与用户信息库中的信息匹配，同时流动出用户信息。</p><p><img src="https://tva4.sinaimg.cn/large/006hWKQzly8h7jzco6wvej30bn07kmx8.jpg"></p><table><thead><tr><th>加工名称：1.1登录</th><th>使用单位：所有用户</th><th></th></tr></thead><tbody><tr><td>输入部分I</td><td>处理描述P</td><td>输出部分O</td></tr><tr><td>用户名、密码</td><td>用户利用自己的用户名和密码进行登录</td><td>用户信息</td></tr></tbody></table><table><thead><tr><th>加工名称：1.2注册</th><th>使用单位：用户</th><th></th></tr></thead><tbody><tr><td>输入部分I</td><td>处理描述P</td><td>输出部分O</td></tr><tr><td>用户注册信息</td><td>新用户输入用户名（邮箱或ID）、密码、昵称，并录入人脸进行注册</td><td>用户信息</td></tr></tbody></table></li><li><p>修改个人信息</p><p>功能描述：用户登录后可以进行相应操作进入个人信息管理界面，用户可以在此页面修改自己的个人信息。</p><table><thead><tr><th>加工名称：2修改个人信息</th><th>使用单位：所有用户</th><th></th></tr></thead><tbody><tr><td>输入部分I</td><td>处理描述P</td><td>输出部分O</td></tr><tr><td>当前用户信息</td><td>用户对自己的个人信息进行修改和保存</td><td>修改后的个人信息</td></tr></tbody></table></li><li><p>查看已预约的会议</p><p>功能描述：用户在首页点击“查询已预约的会议”，进行查询会议室信息库事务，处理传入的用户信息，流动出会议室信息</p><pre><code class=" Mermaid">graph LRA[查看已预约的会议] -- 用户信息 --&gt; B(会议室信息库)B -- 会议主题 --&gt; C&#123;输出&#125;B -- 会议时间 --&gt; C&#123;输出&#125;B -- 会议室地点 --&gt; C&#123;输出&#125;</code></pre><table><thead><tr><th>加工名称：3查看已预约的会议</th><th>使用单位：用户</th><th></th></tr></thead><tbody><tr><td>输入部分I</td><td>处理描述P</td><td>输出部分O</td></tr><tr><td>当前用户信息</td><td>会议室信息库根据输入的用户信息查找对应的会议室</td><td>用户预定的会议的主题、时间、地点</td></tr></tbody></table></li><li><p>查看需参与的会议</p><p>功能描述：用户在首页点击“查看需参与的会议”，进行查询会议室信息库事务，处理传入的用户信息，流动出会议室信息</p><pre><code class=" Mermaid">graph LRA[查看需参与的会议] -- 用户信息 --&gt; B(会议室信息库)B -- 会议主题 --&gt; C&#123;输出&#125;B -- 会议时间 --&gt; C&#123;输出&#125;B -- 会议室地点 --&gt; C&#123;输出&#125;</code></pre><table><thead><tr><th>加工名称：3查看需参与的会议</th><th>使用单位：用户</th><th></th></tr></thead><tbody><tr><td>输入部分I</td><td>处理描述P</td><td>输出部分O</td></tr><tr><td>当前用户信息</td><td>会议室信息库根据输入的用户信息查找对应的会议室</td><td>用户预定的会议的主题、时间、地点</td></tr></tbody></table></li><li><p>发布公告</p><p>功能描述：管理员可以将公告信息传入消息列表数据库</p></li><li><p>查看公告和邀请信息</p><p>功能描述：用户的个人信息传入消息列表，消息列表数据库查询出对应用户的公告和邀请信息，并将对应公告和邀请信息流动给用户，用户即可在其首页进行查看</p></li><li><p>会议室管理</p><p>功能描述：会议室管理信息进入功能划分事务，功能划分事务流动出会议室地点信息及查询指令、会议室信息及添加指令、会议室信息及修改指令。会议室地点信息及查询指令进入查询会议室事务，流动出会议室的其他信息。会议室信息及添加指令进入添加会议室事务，处理出新增的会议室并存入会议室信息库。会议室信息及修改指令进入修改会议室事务，处理出修改后的会议室并存入会议室信息库。会议室地点信息及删除指令进入会议室删除事务，经过处理后流动出待删除会议室从会议室信息库中移除</p><p>（注：若查询会议室没有给出会议室地点，则查询所有会议室的信息）</p><pre><code class=" Mermaid">graph LRA(7.1功能划分) -- 会议室地点信息及查询指令 --&gt; B(7.2查询会议室)B -- 会议室地点 --&gt; E[会议室信息库]E -- 会议室其他信息 --&gt; O&#123;输出&#125;A -- 会议室信息及添加指令 --&gt; D(7.3添加会议室)D -- 会议室信息 --&gt; F((新增的会议室))F -- 会议室信息 --&gt; EA -- 会议室信息及修改指令 --&gt; G(7.4修改会议室)G -- 修改前的会议室信息 --&gt; H((修改后的会议室))H -- 修改后的会议室信息 --&gt; EA -- 会议室地点信息及删除指令 --&gt; I(7.5删除会议室)I -- 待删除会议室信息 --&gt; E</code></pre><table><thead><tr><th>加工名称：7.1功能划分</th><th>使用单位：管理员</th><th></th></tr></thead><tbody><tr><td>输入部分I</td><td>处理描述P</td><td>输出部分O</td></tr><tr><td>用户信息</td><td>系统根据用户信息判断该用户是否有权限进入会议室管理事务</td><td>相关功能所需信息</td></tr></tbody></table><table><thead><tr><th>加工名称：7.2查询会议室</th><th>使用单位：管理员</th><th></th></tr></thead><tbody><tr><td>输入部分I</td><td>处理描述P</td><td>输出部分O</td></tr><tr><td>会议室地点信息及查询指令</td><td>系统根据输入的会议室地点信息将该会议室其他信息展示给用户</td><td>对应会议室的其他信息</td></tr></tbody></table><table><thead><tr><th>加工名称：7.3添加会议室</th><th>使用单位：管理员</th><th></th></tr></thead><tbody><tr><td>输入部分I</td><td>处理描述P</td><td>输出部分O</td></tr><tr><td>会议室信息及添加指令</td><td>系统根据输入的会议室信息新建一个会议室，并将该新会议室的信息流动到会议室信息库</td><td>新会议室信息</td></tr></tbody></table><table><thead><tr><th>加工名称：7.4修改会议室</th><th>使用单位：管理员</th><th></th></tr></thead><tbody><tr><td>输入部分I</td><td>处理描述P</td><td>输出部分O</td></tr><tr><td>会议室信息及修改指令</td><td>系统根据会议室信息查找出待修改的会议室并修改，将修改后的会议室信息流动到会议室信息库</td><td>修改后的会议室信息</td></tr></tbody></table><table><thead><tr><th>加工名称：7.5删除会议室</th><th>使用单位：管理员</th><th></th></tr></thead><tbody><tr><td>输入部分I</td><td>处理描述P</td><td>输出部分O</td></tr><tr><td>会议室地点信息及删除指令</td><td>系统根据会议室地点信息删除该会议室</td><td>删除会议室</td></tr></tbody></table></li><li><p>用户管理</p><p>功能描述：用户管理信息进入功能划分事务，功能划分事务流动出用户名信息及查询指令、用户信息及添加指令、用户信息及修改指令。用户名信息及查询指令进入查询会议室事务，流动出会议室的其他信息。用户信息及添加指令进入添加用户事务，处理出新增的用户并存入用户信息库。用户信息及修改指令进入修改用户事务，处理出修改后的用户并存入用户信息库。用户名信息及删除指令进入用户删除事务，经过处理后流动出待删除用户从用户信息库中移除</p><pre><code class=" Mermaid">graph LRA(7.1功能划分) -- 用户名信息及查询指令 --&gt; B(7.2查询用户)B -- 用户名 --&gt; E[用户信息库]E -- 用户其他信息 --&gt; O&#123;输出&#125;A -- 用户信息及添加指令 --&gt; D(7.3添加用户)D -- 用户信息 --&gt; F((新增的用户))F -- 用户信息 --&gt; EA -- 用户信息及修改指令 --&gt; G(7.4修改用户)G -- 修改前的用户信息 --&gt; H((修改后的用户))H -- 修改后的用户信息 --&gt; EA -- 用户名信息及删除指令 --&gt; I(7.5删除用户)I -- 待删除用户信息 --&gt; E</code></pre><table><thead><tr><th>加工名称：7.1功能划分</th><th>使用单位：管理员</th><th></th></tr></thead><tbody><tr><td>输入部分I</td><td>处理描述P</td><td>输出部分O</td></tr><tr><td>用户信息</td><td>系统根据用户信息判断该用户是否有权限进入用户管理事务</td><td>相关功能所需信息</td></tr></tbody></table><table><thead><tr><th>加工名称：7.2查询会议室</th><th>使用单位：管理员</th><th></th></tr></thead><tbody><tr><td>输入部分I</td><td>处理描述P</td><td>输出部分O</td></tr><tr><td>用户名信息及查询指令</td><td>系统根据输入的用户名信息将该用户其他信息展示给管理员</td><td>对应用户的其他信息</td></tr></tbody></table><table><thead><tr><th>加工名称：7.3添加用户</th><th>使用单位：管理员</th><th></th></tr></thead><tbody><tr><td>输入部分I</td><td>处理描述P</td><td>输出部分O</td></tr><tr><td>用户信息及添加指令</td><td>系统根据输入的用户信息新建一个用户，并将该新用户的信息流动到用户信息库</td><td>新用户信息</td></tr></tbody></table><table><thead><tr><th>加工名称：7.4修改用户</th><th>使用单位：管理员</th><th></th></tr></thead><tbody><tr><td>输入部分I</td><td>处理描述P</td><td>输出部分O</td></tr><tr><td>用户信息及修改指令</td><td>系统根据用户信息查找出待修改的用户并修改，将修改后的用户信息流动到用户信息库</td><td>修改后的用户信息</td></tr></tbody></table><table><thead><tr><th>加工名称：7.5删除用户</th><th>使用单位：管理员</th><th></th></tr></thead><tbody><tr><td>输入部分I</td><td>处理描述P</td><td>输出部分O</td></tr><tr><td>用户名信息及删除指令</td><td>系统根据用户名信息删除该用户</td><td>删除用户</td></tr></tbody></table></li><li><p>预约会议</p><p>功能描述：用户信息（会议发起者）进入预约会议事务，然后查询哪些会议室可用，用户从其中选择一间会议室，填写会议主题、时间、受邀人。预约成功的会议室信息流动到会议室信息库，会议室信息库将修改后的会议室信息流动到消息列表</p><pre><code class=" Mermaid">graph LRA[D1 用户信息库] -- 会议发起者信息 --&gt; B(9.1功能划分)B -- 查询指令 --&gt; C(9.2查询会议室)C -- 查询指令 --&gt; D[D2 会议室信息库]D -- 会议室信息 --&gt; BB -- 修改指令和修改前的会议室信息 --&gt; E(9.3修改会议室)E -- 修改后的会议室信息 --&gt; DD -- 修改后的会议室信息 --&gt; F[D3 消息列表]</code></pre></li></ol><h1 id="数据需求"><a href="#数据需求" class="headerlink" title="数据需求"></a>数据需求</h1><h2 id="静态数据"><a href="#静态数据" class="headerlink" title="静态数据"></a>静态数据</h2><p>用户信息、会议室信息、消息列表</p><h2 id="动态数据"><a href="#动态数据" class="headerlink" title="动态数据"></a>动态数据</h2><p>判断用户某一个行为后的状态码和提示消息</p><h2 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h2><ol><li><p>数据流条目</p><ol><li><p>身份信息</p><table><thead><tr><th>名称</th><th>身份信息</th></tr></thead><tbody><tr><td>简述</td><td>描述管理员和普通用户的身份</td></tr><tr><td>来源</td><td>管理员、普通用户</td></tr><tr><td>去处</td><td>1使用者登录</td></tr></tbody></table></li><li><p>用户名</p><table><thead><tr><th>名称</th><th>用户名</th></tr></thead><tbody><tr><td>简述</td><td>用户登录的账号，可以是邮箱或企业内部ID</td></tr><tr><td>类型</td><td>varchar</td></tr><tr><td>长度</td><td>1024</td></tr><tr><td>来源</td><td>1使用者登录</td></tr><tr><td>去处</td><td>D1用户信息库</td></tr></tbody></table></li><li><p>密码</p><table><thead><tr><th>名称</th><th>密码</th></tr></thead><tbody><tr><td>简述</td><td>用户登录的账号对应的密码</td></tr><tr><td>类型</td><td>varchar</td></tr><tr><td>长度</td><td>1024</td></tr><tr><td>来源</td><td>1使用者登录</td></tr><tr><td>去处</td><td>D1用户信息库</td></tr></tbody></table></li><li><p>人脸信息</p><table><thead><tr><th>名称</th><th>人脸信息</th></tr></thead><tbody><tr><td>简述</td><td>使用者的人脸数据</td></tr><tr><td>类型</td><td>图像</td></tr><tr><td>来源</td><td>1使用者登录</td></tr><tr><td>去处</td><td>D1用户信息库</td></tr></tbody></table></li><li><p>会议主题</p><table><thead><tr><th>名称</th><th>会议主题</th></tr></thead><tbody><tr><td>简述</td><td>普通用户所预定会议的主题</td></tr><tr><td>来源</td><td>9预约会议</td></tr><tr><td>去处</td><td>D2会议室信息库</td></tr></tbody></table></li><li><p>会议时间</p><table><thead><tr><th>名称</th><th>会议时间</th></tr></thead><tbody><tr><td>简述</td><td>普通用户所预定会议的时间</td></tr><tr><td>来源</td><td>9预约会议</td></tr><tr><td>去处</td><td>D2会议室信息库</td></tr></tbody></table></li><li><p>会议室地点</p><table><thead><tr><th>名称</th><th>会议室地点</th></tr></thead><tbody><tr><td>简述</td><td>会议室的门牌号</td></tr><tr><td>来源</td><td>7会议室管理</td></tr><tr><td>去处</td><td>D2会议室信息库</td></tr></tbody></table></li><li><p>会议发起人</p><table><thead><tr><th>名称</th><th>会议发起人</th></tr></thead><tbody><tr><td>简述</td><td>是谁预定了该会议</td></tr><tr><td>来源</td><td>9预约会议</td></tr><tr><td>去处</td><td>D2会议室信息库</td></tr></tbody></table></li><li><p>会议参与人</p><table><thead><tr><th>名称</th><th>会议参与人</th></tr></thead><tbody><tr><td>简述</td><td>会议邀请了哪些人入会</td></tr><tr><td>来源</td><td>9预约会议</td></tr><tr><td>去处</td><td>D2会议室信息库</td></tr></tbody></table></li><li><p>公告</p><table><thead><tr><th>名称</th><th>公告</th></tr></thead><tbody><tr><td>简述</td><td>管理员对每个用户发布的须知</td></tr><tr><td>来源</td><td>管理员</td></tr><tr><td>去处</td><td>D3消息列表</td></tr></tbody></table></li><li><p>邀请信息</p><table><thead><tr><th>名称</th><th>邀请信息</th></tr></thead><tbody><tr><td>简述</td><td>会议受邀人收到的入会通知信息</td></tr><tr><td>来源</td><td>D2会议室信息库</td></tr><tr><td>去处</td><td>D3消息列表</td></tr></tbody></table></li></ol></li><li><p>数据存储条目</p><ol><li><p>用户信息</p><table><thead><tr><th>名称</th><th>用户信息</th></tr></thead><tbody><tr><td>简述</td><td>描述用户的信息</td></tr><tr><td>组成</td><td>用户身份+用户名+密码+昵称+人脸信息</td></tr></tbody></table></li><li><p>会议室信息</p><table><thead><tr><th>名称</th><th>会议室信息</th></tr></thead><tbody><tr><td>简述</td><td>描述会议室的信息</td></tr><tr><td>组成</td><td>会议室地点（+会议主题+会议时间+会议发起人+会议参与人）+会议室容量+会议室设备+空闲标志</td></tr></tbody></table></li></ol></li></ol><h2 id="数据库描述"><a href="#数据库描述" class="headerlink" title="数据库描述"></a>数据库描述</h2><p>软件的数据库概念模型（ER图）</p><p><img src="https://tva3.sinaimg.cn/large/006hWKQzly8h7k79gynogj316p0u0ah4.jpg"></p><p>该ER图有2个实体，分别为用户、会议室数据库，其中用户以用户名为关键字，会议室以地址为关键字，图中关系为一对多的关系</p><h1 id="性能需求"><a href="#性能需求" class="headerlink" title="性能需求"></a>性能需求</h1><h2 id="数据精度"><a href="#数据精度" class="headerlink" title="数据精度"></a>数据精度</h2><table><thead><tr><th>字段</th><th>精度</th><th>备注</th></tr></thead><tbody><tr><td>用户名</td><td>char型或int型</td><td>邮箱或企业内部ID</td></tr><tr><td>密码</td><td>char型</td><td>8-12位</td></tr><tr><td>昵称</td><td>char型</td><td></td></tr><tr><td>会议室是否空闲</td><td>boolean型</td><td>某会议室当前时间段若可用且无人使用值为1，若不能使用值为0</td></tr></tbody></table><h2 id="时间特性"><a href="#时间特性" class="headerlink" title="时间特性"></a>时间特性</h2><ol><li>响应时间：用户任意操作后5秒内系统给予反馈信息。</li><li>更新处理时间：由系统运行状态来决定。</li><li>数据的转换和传送时间：能够在20秒内完成。</li></ol><h2 id="灵活性"><a href="#灵活性" class="headerlink" title="灵活性"></a>灵活性</h2><p>当需求发生某些变化时，该软件的基本操作、数据结构、运行环境等等基本不会发生变化，只是对系统的数据库的文件和记录进行处理，就可以满足需求。</p><h1 id="运行需求"><a href="#运行需求" class="headerlink" title="运行需求"></a>运行需求</h1><h2 id="使用者界面"><a href="#使用者界面" class="headerlink" title="使用者界面"></a>使用者界面</h2><h3 id="普通用户界面"><a href="#普通用户界面" class="headerlink" title="普通用户界面"></a>普通用户界面</h3><ol><li>注册：用户填写该页面的“用户名”、“昵称”、“密码”、“确认密码”信息后点击提交即可成功注册，返回“注册是否成功的消息”。</li><li>登录：用户填写该页面的“用户名”、“密码”信息后点击登录即可成功登录，如果用户没有账号可以点击下方的链接进行注册。</li><li>首页：此页面上方显示“邀请通知”，下面依次为“公告信息”、“你的预约”、“你的参与”点击列表中某个模块可以查看该公告或会议室详情；点击会议发起人或会议受邀人的头像可以查看该用户的“个人信息”</li><li>个人中心：点击用户头像可以修改资料；中间提供该用户的基本数据信息；点击最下方的退出可以登出用户。</li><li>预约：用户在该页面的顶部可以搜索会议室地址以查询会议室情况，页面中部是系统推荐的空闲会议室的列表，点进会议室的模块并填写会议主题、时间、受邀人即可预约会议</li></ol><h3 id="管理员界面"><a href="#管理员界面" class="headerlink" title="管理员界面"></a>管理员界面</h3><ol><li>首页：右上角有注销按钮，可以在此退出或切换账号</li><li>会议室管理：可以在这里查询、增加、删除、修改会议室</li><li>用户管理：可以在这里查询、增加、删除、修改用户</li><li>信息处理：可以在此发布公告、处理预约冲突等异常情况</li></ol><h2 id="软件接口"><a href="#软件接口" class="headerlink" title="软件接口"></a>软件接口</h2><ol><li>操作系统：Microsoft Windows 11</li><li>软件设备：VScode、IntelliJ IDEA、MySQL8.0</li></ol><h2 id="硬件接口"><a href="#硬件接口" class="headerlink" title="硬件接口"></a>硬件接口</h2><ol><li>内存：512M以上</li><li>磁盘空间：40G以上</li><li>CPU：233Mhz以上</li><li>硬盘空间：1.5G以上</li></ol><h1 id="其他需求"><a href="#其他需求" class="headerlink" title="其他需求"></a>其他需求</h1><h2 id="验收标准"><a href="#验收标准" class="headerlink" title="验收标准"></a>验收标准</h2><table><thead><tr><th>测试功能</th><th>测试项</th><th>输入&#x2F;操作</th><th>检验点</th><th>预期结果</th><th>验收</th></tr></thead><tbody><tr><td>登录功能</td><td>登录</td><td>单击用户名输入框，输入用户名</td><td>用户名和密码检查</td><td>符合形式，输入错误，提示用户名或密码有问题，请重新输入</td><td></td></tr><tr><td>单击密码框，输入密码</td><td>密码框保护</td><td>输入的字符在密码框隐藏</td><td></td><td></td><td></td></tr><tr><td>预约界面</td><td>预定会议</td><td>单击会议室模块，输入会议信息</td><td>会议成功预定</td><td>查看首页显示“你的预约”</td><td></td></tr><tr><td>搜索会议室</td><td>在查询框内输入会议室地址</td><td>搜索</td><td>查询框下显示相应的会议室</td><td></td><td></td></tr></tbody></table><h2 id="质量属性"><a href="#质量属性" class="headerlink" title="质量属性"></a>质量属性</h2><ol><li>可用性：用户可以使用</li><li>可靠性：在给定时间内可以大致上满足无错运行的要求</li><li>可维护性：服务器重启、写进日志</li><li>安全性：对用户的密码加密</li><li>可移植性：移动端移植</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>java多线程</title>
    <link href="/2022/10/23/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8A%80%E6%9C%AF%20_%20%E7%BA%BF%E7%A8%8B%E7%94%9F%E6%88%90%20_%20%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    <url>/2022/10/23/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8A%80%E6%9C%AF%20_%20%E7%BA%BF%E7%A8%8B%E7%94%9F%E6%88%90%20_%20%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="java多线程"><a href="#java多线程" class="headerlink" title="java多线程"></a>java多线程</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>java多线程技术相关用法呈现</p><hr><h1 id="一、生成多线程"><a href="#一、生成多线程" class="headerlink" title="一、生成多线程"></a>一、生成多线程</h1><h2 id="1-继承Thread类"><a href="#1-继承Thread类" class="headerlink" title="1.继承Thread类"></a>1.继承Thread类</h2><blockquote><p>创建一个Thread的<strong>子类</strong>的一个实例即创建了一个线程<br>换句话说，它的一个实例 就是一个线程</p></blockquote><p>利用此方法，创建一个Thread的子类的一个实例就是创建了一个线程，<strong>子类中描述了一个线程要做的工作</strong>，因此若多线程要完成不同的工作就要创建多个不同的子类。</p><p>一个子类多次实例化就创建了多个相同的线程，需要注意的是：若子类中含有static类变量，那么这一个子类的多个线程便会操作同一个变量。</p><h2 id="2-实现Runnable接口"><a href="#2-实现Runnable接口" class="headerlink" title="2.实现Runnable接口"></a>2.实现Runnable接口</h2><blockquote><p>将Runnable的一个实现类的一个<strong>实例</strong>放入Thread( ) 构造器中，通过Thread构造器创建线程</p></blockquote><p>通过这种方法，放入同一个实现类实例创建出的多个线程总是会操作这一个实例内的同一些成员变量，当然也完成相同的操作</p><p>因此要完成不同的操作就需要不同的实现类</p><h2 id="3-实现Callable接口"><a href="#3-实现Callable接口" class="headerlink" title="3.实现Callable接口"></a>3.实现Callable接口</h2><blockquote><p>将Callable的实现类的一个<strong>实例</strong>放入FutureTask构造器中创建FutureTas<strong>k实例</strong>，再将Futuretask<strong>实例</strong>放入Thread构造器中创建出一个线程</p></blockquote><h2 id="4-线程池"><a href="#4-线程池" class="headerlink" title="4.线程池"></a>4.线程池</h2><blockquote><p>调用Executors的newFixedThreadPool( )或.newCachedThreadPool(<br>)方法创建出ExecutorService的一个实例，调用该实例的execute( )方法或submit(<br>)方法，在方法中提交含有线程操作的实现Runnable接口或Callable接口实现类对象</p></blockquote><p>说明：<br> execute( )适用于Runnable<br> submit(   ) 适合适用于Callable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.提供指定线程数量的线程池</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">service1</span> <span class="hljs-operator">=</span> (ThreadPoolExecutor) service;<br><span class="hljs-comment">//设置线程池的属性</span><br><span class="hljs-comment">//        System.out.println(service.getClass());</span><br><span class="hljs-comment">//        service1.setCorePoolSize(15);</span><br><span class="hljs-comment">//        service1.setKeepAliveTime();</span><br><br><span class="hljs-comment">//2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象。</span><br>service.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NumberThread</span>()); <span class="hljs-comment">//适合用于Runnable</span><br><span class="hljs-comment">//        service.submit(); 适合适用于Callable</span><br><span class="hljs-comment">//关闭线程池</span><br>service.shutdown();<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/734b75fd8aed4cb5b351991ad4ee9adc.png"></p><h1 id="二、锁"><a href="#二、锁" class="headerlink" title="二、锁"></a>二、锁</h1><blockquote><p>一个Thread子类的实例只能构造一个线程</p></blockquote><blockquote><p> 一个Runnable实现类的实例可以构造多个线程</p></blockquote><p><code>synchronized(同步监视器)&#123;需要被同步的代码&#125;</code></p><h2 id="1-Syncronized同步锁"><a href="#1-Syncronized同步锁" class="headerlink" title="1.Syncronized同步锁"></a>1.Syncronized同步锁</h2><p>关于锁的选择：</p><ul><li><p>自行创建，共用对象，如下面demo中的Object对象。</p></li><li><p>使用this表示当前类的对象</p></li><li><p>继承Thread的方法中的锁不能使用this代替，因为继承thread实现多线程时，会创建多个子类对象来代表多个线程，这个时候this指的时当前这个类的多个对象，不唯一，无法当作锁。</p></li><li><p>实现Runnable接口的方式中，this可以当作锁，因为这种方式只需要创建一个实现类的对象，将实现类的对象传递给多个Thread类对象来当作多个线程，this就是这个一个实现类的对象，是唯一的，被所有线程所共用的对象。</p></li><li><p>使用类当作锁，以下面demo为例，其中的锁可以写为WindowThread.class, 从这里可以得出结论，类也是一个对象</p></li></ul><h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">tiketsNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>   <br>  <span class="hljs-comment">//由于，Runnable实现多线程，所有线程共用一个实现类的对象，所以三个线程都共用实现类中的这个Object类的对象。</span><br>   <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>   <span class="hljs-comment">//如果时继承Thread类实现多线程，那么需要使用到static Object obj = new Object();</span><br>   <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>       <br>  <span class="hljs-comment">//Object obj = new Object();</span><br>    <span class="hljs-comment">//如果Object对象在run()方法中创建，那么每个线程运行都会生成自己的Object类的对象，并不是三个线程的共享对象，所以并没有给加上锁。</span><br>       <br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>           <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>               <span class="hljs-keyword">if</span> (tiketsNum &gt; <span class="hljs-number">0</span>) &#123;<br>                   <span class="hljs-keyword">try</span> &#123;<br>                       <span class="hljs-comment">//手动让线程进入阻塞,增大安全性发生的概率</span><br>                       Thread.sleep(<span class="hljs-number">100</span>);<br>                   &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                       e.printStackTrace();<br>                   &#125;<br>                   System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;:\t票号:&quot;</span> + tiketsNum + <span class="hljs-string">&quot;\t剩余票数:&quot;</span> + --tiketsNum);<br>               &#125; <span class="hljs-keyword">else</span> &#123;<br>                   <span class="hljs-keyword">break</span>;<br>               &#125;<br>           &#125;<br>       &#125;<br></code></pre></td></tr></table></figure><h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><p>同步方法仍然涉及到同步监视器，只是不需要我们显示的声明。<br>非静态的同步方法，同步监视器是：this。<br>静态的同步方法，同步监视器是：当前类本身。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Window02Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">tiketsNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (tiketsNum &gt; <span class="hljs-number">0</span>) &#123;<br>            show();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">//同步监视器：this</span><br>        <span class="hljs-keyword">if</span> (tiketsNum &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//手动让线程进入阻塞,增大安全性发生的概率</span><br>                Thread.sleep(<span class="hljs-number">100</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;:\t票号:&quot;</span> + tiketsNum + <span class="hljs-string">&quot;\t剩余票数:&quot;</span> + --tiketsNum);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Window03Thread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">tiketsNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><br>   <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (tiketsNum &gt; <span class="hljs-number">0</span>) &#123;<br>            show();<br>        &#125;<br>    &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">//同步监视器：Winddoe03Thread.class  不加static话同步监视器为t1 t2 t3所以错误</span><br>        <span class="hljs-keyword">if</span> (tiketsNum &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//手动让线程进入阻塞,增大安全性发生的概率</span><br>                Thread.sleep(<span class="hljs-number">100</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;:\t票号:&quot;</span> + tiketsNum + <span class="hljs-string">&quot;\t剩余票数:&quot;</span> + --tiketsNum);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-Lock锁"><a href="#2-Lock锁" class="headerlink" title="2.Lock锁"></a>2.Lock锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SafeLockThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">tickets</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>   <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (tickets&gt;<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//在这里锁住，有点类似同步监视器</span><br>                lock.lock();<br>                <span class="hljs-keyword">if</span> (tickets &gt; <span class="hljs-number">0</span>) &#123;<br>                    Thread.sleep(<span class="hljs-number">100</span>);<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;:\t票号:&quot;</span> + tickets + <span class="hljs-string">&quot;\t剩余票数:&quot;</span> + --tickets);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">//操作完成共享数据后在这里解锁</span><br>                lock.unlock();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="两种锁之间的异同"><a href="#两种锁之间的异同" class="headerlink" title="两种锁之间的异同"></a>两种锁之间的异同</h2><blockquote><ol><li>Lcok是显式锁（需要手动开启和关闭锁），synchronized是隐式锁，除了作用域自动释放。</li><li>Lock只有代码块锁，synchronized有代码块锁和方法锁。</li><li>使用Lcok锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的拓展性（提供更多的子类</li></ol></blockquote><h2 id="关于死锁："><a href="#关于死锁：" class="headerlink" title="关于死锁："></a>关于死锁：</h2><p>无</p><hr><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="三-线程之间的通信"><a href="#三-线程之间的通信" class="headerlink" title="三.线程之间的通信"></a>三.线程之间的通信</h1><h3 id="相关方法："><a href="#相关方法：" class="headerlink" title="相关方法："></a>相关方法：</h3><blockquote><p>​ wait()：一旦执行此方法，当前线程就会进入阻塞，一旦执行wait()会释放同步监视器。</p></blockquote><blockquote><p>​ notify()：一旦执行此方法，将会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先度最高的。</p></blockquote><blockquote><p>​ notifyAll() ：一旦执行此方法，就会唤醒所有被wait的线程</p></blockquote><p>​ <strong>说明：</strong></p><ul><li><p>​  这三个方法必须在同步代码块或同步方法中使用。</p></li><li><p>三个方法的调用者必须是同步代码块或同步方法中的同步监视器。</p></li><li><p>这三个方法并不定义在Thread类，而是定义在Object类当中。（因为所有的对象都可以作为同步监视器，而这三个方法需要由同步监视器调用，所以任何一个类都要满足，那么只能写在Object类中）</p></li><li><p>在while循环里而不是if语句下使用wait，这样，会在线程暂停恢复后都检查wait的条件，并在条件实际上并未改变的情况下处理唤醒通知</p></li></ul><h1 id="案例：消费者与生产者"><a href="#案例：消费者与生产者" class="headerlink" title="案例：消费者与生产者"></a>案例：消费者与生产者</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * - 经典例题：生产者和消费着问题</span><br><span class="hljs-comment"> * 生产者( Productor)将产品交给店员( Clerk),而消费者( (Customer)从店员处取走产品,</span><br><span class="hljs-comment"> * 店员一次只能持有固定数量的产品(比如:20),如果生产者试图生产更多的产品,店员会叫生产者停一下,</span><br><span class="hljs-comment"> * 如果店中有空位放产品了再通知生产者继续生产; 如果店中没有产品了,店员会告诉消费者等一下,</span><br><span class="hljs-comment"> * 如果店中有产品了再通知消费者来取走产品。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 分析：</span><br><span class="hljs-comment"> * 1.是多线程问题，可以假设多个消费这和多个生产者是多线程的</span><br><span class="hljs-comment"> * 2.存在操作的共享数据，生产和购买时都需要操作经销商的库存存量。</span><br><span class="hljs-comment"> * 3.处理线程安全问题。</span><br><span class="hljs-comment"> * 4.三个类：生产者，经销商，消费者。经销商被生产者和消费者共享。生产者读取经销商库存，当库存不够时，生产产品</span><br><span class="hljs-comment"> * 并发给经销商，操作经销商库存+1。消费者读取经销商库存，当有库存时，方可进行购买，购买完成后，经销商库存-1.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Clerk</span> <span class="hljs-variable">clerk</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Clerk</span>();<br><br>        <span class="hljs-type">Customer</span> <span class="hljs-variable">customer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Customer</span>(clerk);<br>        <span class="hljs-type">Productor</span> <span class="hljs-variable">productor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Productor</span>(clerk);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread_1</span>  <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(customer);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread_2</span>  <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(customer);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread_3</span>  <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(productor);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread_4</span>  <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(productor);<br><br>        thread_1.setName(<span class="hljs-string">&quot;顾客1&quot;</span>);<br>        thread_2.setName(<span class="hljs-string">&quot;顾客2&quot;</span>);<br>        thread_3.setName(<span class="hljs-string">&quot;厂家1&quot;</span>);<br>        thread_4.setName(<span class="hljs-string">&quot;厂家2&quot;</span>);<br><br>        thread_1.start();<br>        thread_2.start();<br>        thread_3.start();<br>        thread_4.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    Clerk clerk;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Customer</span><span class="hljs-params">(Clerk clerk)</span> &#123;<br>        <span class="hljs-built_in">this</span>.clerk = clerk;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>            <span class="hljs-keyword">synchronized</span> (clerk.object)&#123;<br>                clerk.object.notify();<br>                <span class="hljs-keyword">if</span>(clerk.getNum()&gt;<span class="hljs-number">0</span>)&#123;<br>                    System.out.print(<span class="hljs-string">&quot;此时有&quot;</span>+clerk.getNum()+<span class="hljs-string">&quot;个存货  &quot;</span>);<br>                    clerk.buy();<br>                    System.out.println(<span class="hljs-string">&quot;顾客&quot;</span>+Thread.currentThread().getName()+<span class="hljs-string">&quot;购买后有：&quot;</span>+clerk.getNum()+<span class="hljs-string">&quot;个&quot;</span>);<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//不满足购货条件则睡眠</span><br>                    <span class="hljs-keyword">try</span> &#123;<br>                        clerk.object.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Productor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    Clerk clerk;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Productor</span><span class="hljs-params">(Clerk clerk)</span> &#123;<br>        <span class="hljs-built_in">this</span>.clerk = clerk;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br><br>            <span class="hljs-keyword">synchronized</span> (clerk.object)&#123;<br>                clerk.object.notify();<br>                <span class="hljs-keyword">if</span> (clerk.getNum()&lt; clerk.MAX_NUM)&#123;<br>                    System.out.print(<span class="hljs-string">&quot;此时有&quot;</span>+clerk.getNum()+<span class="hljs-string">&quot;个存货  &quot;</span>);<br>                    clerk.addNum();<br>                    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;添货后有&quot;</span>+clerk.getNum()+<span class="hljs-string">&quot;个&quot;</span>);<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">try</span> &#123; <span class="hljs-comment">//不满足加货条件就睡眠</span><br>                        clerk.object.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Clerk</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_NUM</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNum</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> num;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addNum</span><span class="hljs-params">()</span> &#123;<br>        num++;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buy</span><span class="hljs-params">()</span>&#123;<br>        num--;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="四-相关问题"><a href="#四-相关问题" class="headerlink" title="四.相关问题"></a>四.相关问题</h1><h2 id="1-sleep-和wait-的异同"><a href="#1-sleep-和wait-的异同" class="headerlink" title="1.sleep()和wait()的异同"></a>1.sleep()和wait()的异同</h2><blockquote><p>相同点：两个方法一旦执行，都可以让线程进入阻塞状态。</p><p>不同点：<br>(1) 两个方法声明的位置不同：Thread类中声明sleep(),Object类中声明wait()</p><p>(​2) 调用要求不同：sleep()可以在任何需要的场景下调用。wait()必须在同步代码块中调用。</p><p>(​3) 关于是否释放同步监视器：如果两个方法都使用在同步代码块和同步方法中，sleep不会释放锁，wait会释放锁。</p></blockquote><h2 id="2-为什么我们要使用sleep-方法？"><a href="#2-为什么我们要使用sleep-方法？" class="headerlink" title="2.为什么我们要使用sleep( )方法？"></a>2.为什么我们要使用sleep( )方法？</h2><p> 在上述案例中，若不使用sleep( )方法强制休眠线程，就会出现以下的情况：消费者1连续买好几件商品，紧接着厂家1接着连续生产好几件商品。由于cpu执行速度非常快，线程之间的交替执行关系不是特别明显。倘若加了sleep方法，这种情况会稍稍缓和，更有利于线程之间的交替运行。</p><h2 id="3-为什么我们要在同步代码块里使用notify-和wait-方法？"><a href="#3-为什么我们要在同步代码块里使用notify-和wait-方法？" class="headerlink" title="3.为什么我们要在同步代码块里使用notify( )和wait( )方法？"></a>3.为什么我们要在同步代码块里使用notify( )和wait( )方法？</h2><p><a href="https://www.cnblogs.com/myseries/p/13903051.html">wait为什么要在同步块中使用？ 为什么sleep就不用再同步块中</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>tnnd我c盘怎么又爆了</title>
    <link href="/2022/09/25/c/"/>
    <url>/2022/09/25/c/</url>
    
    <content type="html"><![CDATA[<p>西八~~~~</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数字逻辑基础</title>
    <link href="/2022/09/25/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%EF%BC%881%EF%BC%89/"/>
    <url>/2022/09/25/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%EF%BC%881%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="数字逻辑基础"><a href="#数字逻辑基础" class="headerlink" title="数字逻辑基础"></a>数字逻辑基础</h1><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>作为大多数计算机体系结构课程的第一课</p><p>可以说这是我们认识计算机原理的第一步</p><hr><h1 id="一、数值进位制之间的转换"><a href="#一、数值进位制之间的转换" class="headerlink" title="一、数值进位制之间的转换"></a>一、数值进位制之间的转换</h1><blockquote><p>基本概念：基数的个数&#x3D;权</p></blockquote><h2 id="1-与十进制相关的转换"><a href="#1-与十进制相关的转换" class="headerlink" title="1.与十进制相关的转换"></a>1.与十进制相关的转换</h2><h3 id="（1）十进制转化为二、八、十六进制："><a href="#（1）十进制转化为二、八、十六进制：" class="headerlink" title="（1）十进制转化为二、八、十六进制："></a>（1）十进制转化为二、八、十六进制：</h3><p>整数部分除2、8、16取余（最后取得的余数是最高位），小数部分乘2、8、16取整（最先取得的数是最高位）</p><h3 id="（2）其他进制转化为十进制："><a href="#（2）其他进制转化为十进制：" class="headerlink" title="（2）其他进制转化为十进制："></a>（2）其他进制转化为十进制：</h3><p>按权位展开即可（8进制与16进制转化为十进制同理）</p><h2 id="2-二进制与八、十六进制的转换"><a href="#2-二进制与八、十六进制的转换" class="headerlink" title="2.二进制与八、十六进制的转换"></a>2.二进制与八、十六进制的转换</h2><h3 id="（1）二进制转化为八、十六进制"><a href="#（1）二进制转化为八、十六进制" class="headerlink" title="（1）二进制转化为八、十六进制"></a>（1）二进制转化为八、十六进制</h3><p>以小数点为起点，3位、4位为一组（不足为一组的补0），以组为单位转换</p><h3 id="（2）八、十六进制转化为二进制"><a href="#（2）八、十六进制转化为二进制" class="headerlink" title="（2）八、十六进制转化为二进制"></a>（2）八、十六进制转化为二进制</h3><p>将每一位数字转化为3位、4位的对应进制数</p><blockquote><p>介绍完数据的表示，我们有必要了解符号数的表示以及它们的运算是如何进行的</p></blockquote><h1 id="二、机器数"><a href="#二、机器数" class="headerlink" title="二、机器数"></a>二、机器数</h1><blockquote><p>数通常由符号位与数值位组成，符号位通常以0表示正数，1表示负数</p></blockquote><h2 id="1-三种机器数：原码、反码、补码"><a href="#1-三种机器数：原码、反码、补码" class="headerlink" title="1.三种机器数：原码、反码、补码"></a>1.三种机器数：原码、反码、补码</h2><h3 id="（1）原码"><a href="#（1）原码" class="headerlink" title="（1）原码"></a>（1）原码</h3><p>真值的二进制序列加上符号位就是原码<br>原码0有两种表现形式：0.000与1.000</p><h3 id="（2）反码"><a href="#（2）反码" class="headerlink" title="（2）反码"></a>（2）反码</h3><p>正数的反码等于原码<br>负数的反码是除符号位外，其余位按位求反（01互换）<br>反码0有两种表现形式：0.000与1.111</p><h3 id="（3）补码"><a href="#（3）补码" class="headerlink" title="（3）补码"></a>（3）补码</h3><p>正数的补码等于原码<br>负数的补码是除符号位外，其余位按位求反，再整体+1<br>补码0的表示是唯一的：0.000</p><h2 id="2-机器数的运算"><a href="#2-机器数的运算" class="headerlink" title="2.机器数的运算"></a>2.机器数的运算</h2><p>对于原码，先对真值二进制数进行运算，最后添加符号位</p><h3 id="补码运算："><a href="#补码运算：" class="headerlink" title="补码运算："></a>补码运算：</h3><blockquote><p><em><strong>对补码再求补码或反码再求反码即可得到原码</strong></em></p></blockquote><p>补码直接参与运算，符号位产生进位时舍弃溢出部分<br>结果的符号位为0时，说明是正数的补码，其与原码相同。符号位为1时，说明是负数的补码，应再对运算结果再求补码，才得到原码。<br><img src="https://img-blog.csdnimg.cn/4b953f4029cd453ba10488e90e5c5491.png"><br><img src="https://img-blog.csdnimg.cn/e21dd1714c79473faf228b9fb9019d03.png"></p><h3 id="反码运算"><a href="#反码运算" class="headerlink" title="反码运算"></a>反码运算</h3><p><img src="https://img-blog.csdnimg.cn/62022fea85594e07ab85082772a400a7.png"><br>        运算时，符号位参加运算，如果符号位产生了进位，则该进位应该加到和数的最低位，称之为“循环进位”。<br>        运算结果符号位为0时，说明是正数的反码，其与原码相同。若符号位为1，说明是负数的反码，应对结果再求反码才能得到原码。</p><h1 id="三、浮点数的表示、IEEE754标准"><a href="#三、浮点数的表示、IEEE754标准" class="headerlink" title="三、浮点数的表示、IEEE754标准"></a>三、浮点数的表示、IEEE754标准</h1><p>浮点数的表示有两部分组成：阶码E+尾数M<br>真值    N &#x3D; ± R^E ×M<br>概念冗杂（哈哈哈）<br>我们直接来例子：<img src="https://img-blog.csdnimg.cn/d764307f7f7648e09752421494505dc4.png"><br><img src="https://img-blog.csdnimg.cn/b8f27030c15c4107a6f930d20b028efa.png"><br><img src="https://img-blog.csdnimg.cn/0312d37670ef4158871885af4ada8322.png"><br><img src="https://img-blog.csdnimg.cn/e08af18ff57c41bb9c6f6495bbc96ea4.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/09/18/hello-world/"/>
    <url>/2022/09/18/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
