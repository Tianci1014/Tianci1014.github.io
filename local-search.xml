<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>java多线程</title>
    <link href="/2022/10/23/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8A%80%E6%9C%AF%20_%20%E7%BA%BF%E7%A8%8B%E7%94%9F%E6%88%90%20_%20%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    <url>/2022/10/23/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8A%80%E6%9C%AF%20_%20%E7%BA%BF%E7%A8%8B%E7%94%9F%E6%88%90%20_%20%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="java多线程"><a href="#java多线程" class="headerlink" title="java多线程"></a>java多线程</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>java多线程技术相关用法呈现</p><hr><h1 id="一、生成多线程"><a href="#一、生成多线程" class="headerlink" title="一、生成多线程"></a>一、生成多线程</h1><h2 id="1-继承Thread类"><a href="#1-继承Thread类" class="headerlink" title="1.继承Thread类"></a>1.继承Thread类</h2><blockquote><p>创建一个Thread的<strong>子类</strong>的一个实例即创建了一个线程<br>换句话说，它的一个实例 就是一个线程</p></blockquote><p>利用此方法，创建一个Thread的子类的一个实例就是创建了一个线程，<strong>子类中描述了一个线程要做的工作</strong>，因此若多线程要完成不同的工作就要创建多个不同的子类。</p><p>一个子类多次实例化就创建了多个相同的线程，需要注意的是：若子类中含有static类变量，那么这一个子类的多个线程便会操作同一个变量。</p><h2 id="2-实现Runnable接口"><a href="#2-实现Runnable接口" class="headerlink" title="2.实现Runnable接口"></a>2.实现Runnable接口</h2><blockquote><p>将Runnable的一个实现类的一个<strong>实例</strong>放入Thread( ) 构造器中，通过Thread构造器创建线程</p></blockquote><p>通过这种方法，放入同一个实现类实例创建出的多个线程总是会操作这一个实例内的同一些成员变量，当然也完成相同的操作</p><p>因此要完成不同的操作就需要不同的实现类</p><h2 id="3-实现Callable接口"><a href="#3-实现Callable接口" class="headerlink" title="3.实现Callable接口"></a>3.实现Callable接口</h2><blockquote><p>将Callable的实现类的一个<strong>实例</strong>放入FutureTask构造器中创建FutureTas<strong>k实例</strong>，再将Futuretask<strong>实例</strong>放入Thread构造器中创建出一个线程</p></blockquote><h2 id="4-线程池"><a href="#4-线程池" class="headerlink" title="4.线程池"></a>4.线程池</h2><blockquote><p>调用Executors的newFixedThreadPool( )或.newCachedThreadPool(<br>)方法创建出ExecutorService的一个实例，调用该实例的execute( )方法或submit(<br>)方法，在方法中提交含有线程操作的实现Runnable接口或Callable接口实现类对象</p></blockquote><p>说明：<br> execute( )适用于Runnable<br> submit(   ) 适合适用于Callable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.提供指定线程数量的线程池</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">service1</span> <span class="hljs-operator">=</span> (ThreadPoolExecutor) service;<br><span class="hljs-comment">//设置线程池的属性</span><br><span class="hljs-comment">//        System.out.println(service.getClass());</span><br><span class="hljs-comment">//        service1.setCorePoolSize(15);</span><br><span class="hljs-comment">//        service1.setKeepAliveTime();</span><br><br><span class="hljs-comment">//2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象。</span><br>service.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NumberThread</span>()); <span class="hljs-comment">//适合用于Runnable</span><br><span class="hljs-comment">//        service.submit(); 适合适用于Callable</span><br><span class="hljs-comment">//关闭线程池</span><br>service.shutdown();<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/734b75fd8aed4cb5b351991ad4ee9adc.png"></p><h1 id="二、锁"><a href="#二、锁" class="headerlink" title="二、锁"></a>二、锁</h1><blockquote><p>一个Thread子类的实例只能构造一个线程</p></blockquote><blockquote><p> 一个Runnable实现类的实例可以构造多个线程</p></blockquote><p><code>synchronized(同步监视器)&#123;需要被同步的代码&#125;</code></p><h2 id="1-Syncronized同步锁"><a href="#1-Syncronized同步锁" class="headerlink" title="1.Syncronized同步锁"></a>1.Syncronized同步锁</h2><p>关于锁的选择：</p><ul><li><p>自行创建，共用对象，如下面demo中的Object对象。</p></li><li><p>使用this表示当前类的对象</p></li><li><p>继承Thread的方法中的锁不能使用this代替，因为继承thread实现多线程时，会创建多个子类对象来代表多个线程，这个时候this指的时当前这个类的多个对象，不唯一，无法当作锁。</p></li><li><p>实现Runnable接口的方式中，this可以当作锁，因为这种方式只需要创建一个实现类的对象，将实现类的对象传递给多个Thread类对象来当作多个线程，this就是这个一个实现类的对象，是唯一的，被所有线程所共用的对象。</p></li><li><p>使用类当作锁，以下面demo为例，其中的锁可以写为WindowThread.class, 从这里可以得出结论，类也是一个对象</p></li></ul><h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">tiketsNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>   <br>  <span class="hljs-comment">//由于，Runnable实现多线程，所有线程共用一个实现类的对象，所以三个线程都共用实现类中的这个Object类的对象。</span><br>   <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>   <span class="hljs-comment">//如果时继承Thread类实现多线程，那么需要使用到static Object obj = new Object();</span><br>   <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>       <br>  <span class="hljs-comment">//Object obj = new Object();</span><br>    <span class="hljs-comment">//如果Object对象在run()方法中创建，那么每个线程运行都会生成自己的Object类的对象，并不是三个线程的共享对象，所以并没有给加上锁。</span><br>       <br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>           <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>               <span class="hljs-keyword">if</span> (tiketsNum &gt; <span class="hljs-number">0</span>) &#123;<br>                   <span class="hljs-keyword">try</span> &#123;<br>                       <span class="hljs-comment">//手动让线程进入阻塞,增大安全性发生的概率</span><br>                       Thread.sleep(<span class="hljs-number">100</span>);<br>                   &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                       e.printStackTrace();<br>                   &#125;<br>                   System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;:\t票号:&quot;</span> + tiketsNum + <span class="hljs-string">&quot;\t剩余票数:&quot;</span> + --tiketsNum);<br>               &#125; <span class="hljs-keyword">else</span> &#123;<br>                   <span class="hljs-keyword">break</span>;<br>               &#125;<br>           &#125;<br>       &#125;<br></code></pre></td></tr></table></figure><h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><p>同步方法仍然涉及到同步监视器，只是不需要我们显示的声明。<br>非静态的同步方法，同步监视器是：this。<br>静态的同步方法，同步监视器是：当前类本身。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Window02Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">tiketsNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (tiketsNum &gt; <span class="hljs-number">0</span>) &#123;<br>            show();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">//同步监视器：this</span><br>        <span class="hljs-keyword">if</span> (tiketsNum &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//手动让线程进入阻塞,增大安全性发生的概率</span><br>                Thread.sleep(<span class="hljs-number">100</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;:\t票号:&quot;</span> + tiketsNum + <span class="hljs-string">&quot;\t剩余票数:&quot;</span> + --tiketsNum);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Window03Thread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">tiketsNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><br>   <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (tiketsNum &gt; <span class="hljs-number">0</span>) &#123;<br>            show();<br>        &#125;<br>    &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">//同步监视器：Winddoe03Thread.class  不加static话同步监视器为t1 t2 t3所以错误</span><br>        <span class="hljs-keyword">if</span> (tiketsNum &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//手动让线程进入阻塞,增大安全性发生的概率</span><br>                Thread.sleep(<span class="hljs-number">100</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;:\t票号:&quot;</span> + tiketsNum + <span class="hljs-string">&quot;\t剩余票数:&quot;</span> + --tiketsNum);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-Lock锁"><a href="#2-Lock锁" class="headerlink" title="2.Lock锁"></a>2.Lock锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SafeLockThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">tickets</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>   <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (tickets&gt;<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//在这里锁住，有点类似同步监视器</span><br>                lock.lock();<br>                <span class="hljs-keyword">if</span> (tickets &gt; <span class="hljs-number">0</span>) &#123;<br>                    Thread.sleep(<span class="hljs-number">100</span>);<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;:\t票号:&quot;</span> + tickets + <span class="hljs-string">&quot;\t剩余票数:&quot;</span> + --tickets);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">//操作完成共享数据后在这里解锁</span><br>                lock.unlock();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="两种锁之间的异同"><a href="#两种锁之间的异同" class="headerlink" title="两种锁之间的异同"></a>两种锁之间的异同</h2><blockquote><ol><li>Lcok是显式锁（需要手动开启和关闭锁），synchronized是隐式锁，除了作用域自动释放。</li><li>Lock只有代码块锁，synchronized有代码块锁和方法锁。</li><li>使用Lcok锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的拓展性（提供更多的子类</li></ol></blockquote><h2 id="关于死锁："><a href="#关于死锁：" class="headerlink" title="关于死锁："></a>关于死锁：</h2><p>无</p><hr><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="三-线程之间的通信"><a href="#三-线程之间的通信" class="headerlink" title="三.线程之间的通信"></a>三.线程之间的通信</h1><h3 id="相关方法："><a href="#相关方法：" class="headerlink" title="相关方法："></a>相关方法：</h3><blockquote><p>​ wait()：一旦执行此方法，当前线程就会进入阻塞，一旦执行wait()会释放同步监视器。</p></blockquote><blockquote><p>​ notify()：一旦执行此方法，将会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先度最高的。</p></blockquote><blockquote><p>​ notifyAll() ：一旦执行此方法，就会唤醒所有被wait的线程</p></blockquote><p>​ <strong>说明：</strong></p><ul><li><p>​  这三个方法必须在同步代码块或同步方法中使用。</p></li><li><p>三个方法的调用者必须是同步代码块或同步方法中的同步监视器。</p></li><li><p>这三个方法并不定义在Thread类，而是定义在Object类当中。（因为所有的对象都可以作为同步监视器，而这三个方法需要由同步监视器调用，所以任何一个类都要满足，那么只能写在Object类中）</p></li><li><p>在while循环里而不是if语句下使用wait，这样，会在线程暂停恢复后都检查wait的条件，并在条件实际上并未改变的情况下处理唤醒通知</p></li></ul><h1 id="案例：消费者与生产者"><a href="#案例：消费者与生产者" class="headerlink" title="案例：消费者与生产者"></a>案例：消费者与生产者</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * - 经典例题：生产者和消费着问题</span><br><span class="hljs-comment"> * 生产者( Productor)将产品交给店员( Clerk),而消费者( (Customer)从店员处取走产品,</span><br><span class="hljs-comment"> * 店员一次只能持有固定数量的产品(比如:20),如果生产者试图生产更多的产品,店员会叫生产者停一下,</span><br><span class="hljs-comment"> * 如果店中有空位放产品了再通知生产者继续生产; 如果店中没有产品了,店员会告诉消费者等一下,</span><br><span class="hljs-comment"> * 如果店中有产品了再通知消费者来取走产品。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 分析：</span><br><span class="hljs-comment"> * 1.是多线程问题，可以假设多个消费这和多个生产者是多线程的</span><br><span class="hljs-comment"> * 2.存在操作的共享数据，生产和购买时都需要操作经销商的库存存量。</span><br><span class="hljs-comment"> * 3.处理线程安全问题。</span><br><span class="hljs-comment"> * 4.三个类：生产者，经销商，消费者。经销商被生产者和消费者共享。生产者读取经销商库存，当库存不够时，生产产品</span><br><span class="hljs-comment"> * 并发给经销商，操作经销商库存+1。消费者读取经销商库存，当有库存时，方可进行购买，购买完成后，经销商库存-1.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Clerk</span> <span class="hljs-variable">clerk</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Clerk</span>();<br><br>        <span class="hljs-type">Customer</span> <span class="hljs-variable">customer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Customer</span>(clerk);<br>        <span class="hljs-type">Productor</span> <span class="hljs-variable">productor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Productor</span>(clerk);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread_1</span>  <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(customer);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread_2</span>  <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(customer);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread_3</span>  <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(productor);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread_4</span>  <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(productor);<br><br>        thread_1.setName(<span class="hljs-string">&quot;顾客1&quot;</span>);<br>        thread_2.setName(<span class="hljs-string">&quot;顾客2&quot;</span>);<br>        thread_3.setName(<span class="hljs-string">&quot;厂家1&quot;</span>);<br>        thread_4.setName(<span class="hljs-string">&quot;厂家2&quot;</span>);<br><br>        thread_1.start();<br>        thread_2.start();<br>        thread_3.start();<br>        thread_4.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    Clerk clerk;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Customer</span><span class="hljs-params">(Clerk clerk)</span> &#123;<br>        <span class="hljs-built_in">this</span>.clerk = clerk;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>            <span class="hljs-keyword">synchronized</span> (clerk.object)&#123;<br>                clerk.object.notify();<br>                <span class="hljs-keyword">if</span>(clerk.getNum()&gt;<span class="hljs-number">0</span>)&#123;<br>                    System.out.print(<span class="hljs-string">&quot;此时有&quot;</span>+clerk.getNum()+<span class="hljs-string">&quot;个存货  &quot;</span>);<br>                    clerk.buy();<br>                    System.out.println(<span class="hljs-string">&quot;顾客&quot;</span>+Thread.currentThread().getName()+<span class="hljs-string">&quot;购买后有：&quot;</span>+clerk.getNum()+<span class="hljs-string">&quot;个&quot;</span>);<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//不满足购货条件则睡眠</span><br>                    <span class="hljs-keyword">try</span> &#123;<br>                        clerk.object.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Productor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    Clerk clerk;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Productor</span><span class="hljs-params">(Clerk clerk)</span> &#123;<br>        <span class="hljs-built_in">this</span>.clerk = clerk;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br><br>            <span class="hljs-keyword">synchronized</span> (clerk.object)&#123;<br>                clerk.object.notify();<br>                <span class="hljs-keyword">if</span> (clerk.getNum()&lt; clerk.MAX_NUM)&#123;<br>                    System.out.print(<span class="hljs-string">&quot;此时有&quot;</span>+clerk.getNum()+<span class="hljs-string">&quot;个存货  &quot;</span>);<br>                    clerk.addNum();<br>                    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;添货后有&quot;</span>+clerk.getNum()+<span class="hljs-string">&quot;个&quot;</span>);<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">try</span> &#123; <span class="hljs-comment">//不满足加货条件就睡眠</span><br>                        clerk.object.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Clerk</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_NUM</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNum</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> num;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addNum</span><span class="hljs-params">()</span> &#123;<br>        num++;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buy</span><span class="hljs-params">()</span>&#123;<br>        num--;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="四-相关问题"><a href="#四-相关问题" class="headerlink" title="四.相关问题"></a>四.相关问题</h1><h2 id="1-sleep-和wait-的异同"><a href="#1-sleep-和wait-的异同" class="headerlink" title="1.sleep()和wait()的异同"></a>1.sleep()和wait()的异同</h2><blockquote><p>相同点：两个方法一旦执行，都可以让线程进入阻塞状态。</p><p>不同点：<br>(1) 两个方法声明的位置不同：Thread类中声明sleep(),Object类中声明wait()</p><p>(​2) 调用要求不同：sleep()可以在任何需要的场景下调用。wait()必须在同步代码块中调用。</p><p>(​3) 关于是否释放同步监视器：如果两个方法都使用在同步代码块和同步方法中，sleep不会释放锁，wait会释放锁。</p></blockquote><h2 id="2-为什么我们要使用sleep-方法？"><a href="#2-为什么我们要使用sleep-方法？" class="headerlink" title="2.为什么我们要使用sleep( )方法？"></a>2.为什么我们要使用sleep( )方法？</h2><p> 在上述案例中，若不使用sleep( )方法强制休眠线程，就会出现以下的情况：消费者1连续买好几件商品，紧接着厂家1接着连续生产好几件商品。由于cpu执行速度非常快，线程之间的交替执行关系不是特别明显。倘若加了sleep方法，这种情况会稍稍缓和，更有利于线程之间的交替运行。</p><h2 id="3-为什么我们要在同步代码块里使用notify-和wait-方法？"><a href="#3-为什么我们要在同步代码块里使用notify-和wait-方法？" class="headerlink" title="3.为什么我们要在同步代码块里使用notify( )和wait( )方法？"></a>3.为什么我们要在同步代码块里使用notify( )和wait( )方法？</h2><p><a href="https://www.cnblogs.com/myseries/p/13903051.html">wait为什么要在同步块中使用？ 为什么sleep就不用再同步块中</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>tnnd我c盘怎么又爆了</title>
    <link href="/2022/09/25/c/"/>
    <url>/2022/09/25/c/</url>
    
    <content type="html"><![CDATA[<p>西八~~~~</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数字逻辑基础</title>
    <link href="/2022/09/25/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%EF%BC%881%EF%BC%89/"/>
    <url>/2022/09/25/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%EF%BC%881%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="数字逻辑基础"><a href="#数字逻辑基础" class="headerlink" title="数字逻辑基础"></a>数字逻辑基础</h1><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>作为大多数计算机体系结构课程的第一课</p><p>可以说这是我们认识计算机原理的第一步</p><hr><h1 id="一、数值进位制之间的转换"><a href="#一、数值进位制之间的转换" class="headerlink" title="一、数值进位制之间的转换"></a>一、数值进位制之间的转换</h1><blockquote><p>基本概念：基数的个数&#x3D;权</p></blockquote><h2 id="1-与十进制相关的转换"><a href="#1-与十进制相关的转换" class="headerlink" title="1.与十进制相关的转换"></a>1.与十进制相关的转换</h2><h3 id="（1）十进制转化为二、八、十六进制："><a href="#（1）十进制转化为二、八、十六进制：" class="headerlink" title="（1）十进制转化为二、八、十六进制："></a>（1）十进制转化为二、八、十六进制：</h3><p>整数部分除2、8、16取余（最后取得的余数是最高位），小数部分乘2、8、16取整（最先取得的数是最高位）</p><h3 id="（2）其他进制转化为十进制："><a href="#（2）其他进制转化为十进制：" class="headerlink" title="（2）其他进制转化为十进制："></a>（2）其他进制转化为十进制：</h3><p>按权位展开即可（8进制与16进制转化为十进制同理）</p><h2 id="2-二进制与八、十六进制的转换"><a href="#2-二进制与八、十六进制的转换" class="headerlink" title="2.二进制与八、十六进制的转换"></a>2.二进制与八、十六进制的转换</h2><h3 id="（1）二进制转化为八、十六进制"><a href="#（1）二进制转化为八、十六进制" class="headerlink" title="（1）二进制转化为八、十六进制"></a>（1）二进制转化为八、十六进制</h3><p>以小数点为起点，3位、4位为一组（不足为一组的补0），以组为单位转换</p><h3 id="（2）八、十六进制转化为二进制"><a href="#（2）八、十六进制转化为二进制" class="headerlink" title="（2）八、十六进制转化为二进制"></a>（2）八、十六进制转化为二进制</h3><p>将每一位数字转化为3位、4位的对应进制数</p><blockquote><p>介绍完数据的表示，我们有必要了解符号数的表示以及它们的运算是如何进行的</p></blockquote><h1 id="二、机器数"><a href="#二、机器数" class="headerlink" title="二、机器数"></a>二、机器数</h1><blockquote><p>数通常由符号位与数值位组成，符号位通常以0表示正数，1表示负数</p></blockquote><h2 id="1-三种机器数：原码、反码、补码"><a href="#1-三种机器数：原码、反码、补码" class="headerlink" title="1.三种机器数：原码、反码、补码"></a>1.三种机器数：原码、反码、补码</h2><h3 id="（1）原码"><a href="#（1）原码" class="headerlink" title="（1）原码"></a>（1）原码</h3><p>真值的二进制序列加上符号位就是原码<br>原码0有两种表现形式：0.000与1.000</p><h3 id="（2）反码"><a href="#（2）反码" class="headerlink" title="（2）反码"></a>（2）反码</h3><p>正数的反码等于原码<br>负数的反码是除符号位外，其余位按位求反（01互换）<br>反码0有两种表现形式：0.000与1.111</p><h3 id="（3）补码"><a href="#（3）补码" class="headerlink" title="（3）补码"></a>（3）补码</h3><p>正数的补码等于原码<br>负数的补码是除符号位外，其余位按位求反，再整体+1<br>补码0的表示是唯一的：0.000</p><h2 id="2-机器数的运算"><a href="#2-机器数的运算" class="headerlink" title="2.机器数的运算"></a>2.机器数的运算</h2><p>对于原码，先对真值二进制数进行运算，最后添加符号位</p><h3 id="补码运算："><a href="#补码运算：" class="headerlink" title="补码运算："></a>补码运算：</h3><blockquote><p><em><strong>对补码再求补码或反码再求反码即可得到原码</strong></em></p></blockquote><p>补码直接参与运算，符号位产生进位时舍弃溢出部分<br>结果的符号位为0时，说明是正数的补码，其与原码相同。符号位为1时，说明是负数的补码，应再对运算结果再求补码，才得到原码。<br><img src="https://img-blog.csdnimg.cn/4b953f4029cd453ba10488e90e5c5491.png"><br><img src="https://img-blog.csdnimg.cn/e21dd1714c79473faf228b9fb9019d03.png"></p><h3 id="反码运算"><a href="#反码运算" class="headerlink" title="反码运算"></a>反码运算</h3><p><img src="https://img-blog.csdnimg.cn/62022fea85594e07ab85082772a400a7.png"><br>        运算时，符号位参加运算，如果符号位产生了进位，则该进位应该加到和数的最低位，称之为“循环进位”。<br>        运算结果符号位为0时，说明是正数的反码，其与原码相同。若符号位为1，说明是负数的反码，应对结果再求反码才能得到原码。</p><h1 id="三、浮点数的表示、IEEE754标准"><a href="#三、浮点数的表示、IEEE754标准" class="headerlink" title="三、浮点数的表示、IEEE754标准"></a>三、浮点数的表示、IEEE754标准</h1><p>浮点数的表示有两部分组成：阶码E+尾数M<br>真值    N &#x3D; ± R^E ×M<br>概念冗杂（哈哈哈）<br>我们直接来例子：<img src="https://img-blog.csdnimg.cn/d764307f7f7648e09752421494505dc4.png"><br><img src="https://img-blog.csdnimg.cn/b8f27030c15c4107a6f930d20b028efa.png"><br><img src="https://img-blog.csdnimg.cn/0312d37670ef4158871885af4ada8322.png"><br><img src="https://img-blog.csdnimg.cn/e08af18ff57c41bb9c6f6495bbc96ea4.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/09/18/hello-world/"/>
    <url>/2022/09/18/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
